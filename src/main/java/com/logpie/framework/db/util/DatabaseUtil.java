package com.logpie.framework.db.util;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.Timestamp;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.logpie.framework.db.annotation.AutoGenerate;
import com.logpie.framework.db.annotation.Column;
import com.logpie.framework.db.annotation.ForeignEntity;
import com.logpie.framework.db.annotation.ID;
import com.logpie.framework.db.annotation.Table;

public class DatabaseUtil {

	private static final Logger logger = Logger.getLogger(DatabaseUtil.class
			.getName());

	/**
	 * get columns of Class c without foreign key columns
	 * 
	 * @param c
	 * @param hasAutogeneratedKey
	 * @return column names with table alias or name
	 */
	public static List<String> getBasicColumns(final Class<?> c,
			final boolean hasAutogeneratedKey) {
		List<String> res = new ArrayList<String>();
		List<Column> columns = getColumnAnnotations(c, hasAutogeneratedKey);
		if (columns == null || columns.isEmpty()) {
			logger.log(Level.SEVERE, "cannot find columns in table "
					+ getTableAnnotation(c));
			return null;
		}
		for (Column column : columns) {
			res.add(getTableAliasOrName(c) + "." + column.name());
		}
		return res;
	}

	/**
	 * get all columns of Class c
	 * 
	 * @param c
	 * @return column names with table alias or name
	 */
	public static List<String> getAllColumns(final Class<?> c) {
		List<String> res = new ArrayList<String>();
		res.addAll(getBasicColumns(c, true));

		List<ForeignEntity> foreignEntities = getForeignEntityAnnotations(c);
		for (ForeignEntity entity : foreignEntities) {
			res.add(getTableAliasOrName(c) + "." + entity.name());
		}
		return res;
	}

	/**
	 * get basic columns of all linked tables(included linked tables of linked
	 * table)
	 * 
	 * @param c
	 * @return column names with table alias or name
	 */
	public static List<String> getAllLinkedColumns(final Class<?> c) {
		List<String> res = new ArrayList<String>();

		List<ForeignEntity> foreignEntities = getForeignEntityAnnotations(c);
		for (ForeignEntity entity : foreignEntities) {
			List<Column> referencedKeys = new ArrayList<Column>();
			referencedKeys.addAll(getColumnAnnotations(
					entity.referencedTable(), true));
			for (Column key : referencedKeys) {
				res.add(getTableAliasOrName(entity.referencedTable()) + "."
						+ key.name());
			}
		}

		return res;
	}

	/**
	 * get column and non-null value pairs of model by using "," to split,
	 * without auto-generated columns
	 * 
	 * @param model
	 * @return a list of column and value pair in SQL string, which means a
	 *         string value will be wrapped in single quotes
	 */
	public static List<String> getColumnValuePairs(final LogpieModel model,
			final boolean hasAutogeneratedKey) {
		Map<String, Object> modelMap = getModelMap(model, hasAutogeneratedKey);
		if (modelMap == null || modelMap.isEmpty()) {
			logger.log(Level.SEVERE, "cannot get model map in table "
					+ getTableAnnotation(model.getClass()));
			return null;
		}

		List<String> res = new ArrayList<String>();
		for (Map.Entry<String, Object> entry : modelMap.entrySet()) {
			// check value of corresponding property is null
			if (entry.getValue() == null) {
				continue;
			}

			String pair = entry.getKey()
					+ ","
					+ toSqlString(model.getClass(), entry.getKey(),
							entry.getValue());
			res.add(pair);
		}

		return res;
	}

	public static Class<?> getBasicColumnTypeByName(final Class<?> c,
			final String name) {
		List<Column> columnList = getColumnAnnotations(c, true);
		for (Column column : columnList) {
			if (column.name().equals(name)) {
				switch (column.type()) {
				case BOOLEAN:
					return Boolean.class;
				case INT:
					return Integer.class;
				case LONG:
					return Long.class;
				case FLOAT:
					return Float.class;
				case TIMESTAMP:
					return Timestamp.class;
				default:
					return String.class;
				}
			}
		}
		if (hasForeignEntityAnnotation(c)) {
			List<ForeignEntity> entityList = getForeignEntityAnnotations(c);
			for (ForeignEntity entity : entityList) {
				if (entity.name().equals(name)) {
					return Long.class;
				}
			}
		}
		logger.log(Level.WARNING,
				"cannot find " + name + " column in " + c.getName());
		return null;
	}

	public static String getID(final Class<?> c) {
		Field[] fields = c.getDeclaredFields();
		for (Field field : fields) {
			if (field.isAnnotationPresent(ID.class)
					&& field.isAnnotationPresent(Column.class)) {
				return field.getAnnotation(Column.class).name();
			}
		}
		logger.log(Level.WARNING, "cannot find any ID from this table");
		return null;
	}

	public static String getTableName(final Class<?> c) {
		if (getTableAnnotation(c) == null) {
			logger.log(Level.WARNING, "cannot find any table");
			return null;
		}
		return getTableAnnotation(c).name();
	}

	/**
	 * build a map between database keys and java entities
	 * 
	 * @param model
	 *            is related java entity instance
	 * @param hasAutogeneratedKey
	 *            determines whether the map contains auto-generated keys
	 * @return a hash-map which is mapping database key to java entity, where
	 *         key is database key name and value is java entity
	 */
	public static Map<String, Object> getModelMap(final LogpieModel model,
			final boolean hasAutogeneratedKey) {
		final Map<String, Object> result = new HashMap<String, Object>();
		Field[] fields = model.getClass().getDeclaredFields();
		for (Field field : fields) {
			// find every field of this model corresponding database column
			if (field.isAnnotationPresent(Column.class)) {
				Column column = field.getAnnotation(Column.class);
				if (!hasAutogeneratedKey
						&& field.isAnnotationPresent(AutoGenerate.class)) {
					continue;
				}
				// get value of this field
				Object value = runGetter(field, model);
				result.put(column.name(), value);
			}
			// find every field of model corresponding foreign key
			else if (field.isAnnotationPresent(ForeignEntity.class)) {
				// get this foreign table model
				LogpieModel entity = (LogpieModel) runGetter(field, model);
				ForeignEntity column = field.getAnnotation(ForeignEntity.class);
				// get fields of table
				Field[] referencedFields = column.referencedTable()
						.getDeclaredFields();
				for (Field f : referencedFields) {
					// find the field representing ID of foreign table
					if (f.isAnnotationPresent(ID.class)) {
						result.put(column.name(), runGetter(f, entity));
						break;
					}
				}
			}

		}
		return result;
	}

	static List<Column> getColumnAnnotations(final Class<?> c,
			final boolean hasAutogeneratedKey) {
		List<Column> res = new ArrayList<Column>();

		Field[] fields = c.getDeclaredFields();
		for (Field field : fields) {
			if (field.isAnnotationPresent(Column.class)) {
				Column column = field.getAnnotation(Column.class);
				if (!hasAutogeneratedKey
						&& field.isAnnotationPresent(AutoGenerate.class)) {
					continue;
				}
				res.add(column);
			}
		}
		return res;
	}

	static List<ForeignEntity> getForeignEntityAnnotations(final Class<?> c) {
		List<ForeignEntity> res = new ArrayList<ForeignEntity>();

		List<ForeignEntity> keys = new ArrayList<ForeignEntity>();
		Field[] fields = c.getDeclaredFields();
		for (Field field : fields) {
			if (field.isAnnotationPresent(ForeignEntity.class)) {
				ForeignEntity column = field.getAnnotation(ForeignEntity.class);
				keys.add(column);
				res.add(column);
			}
		}
		while (!keys.isEmpty()) {
			List<ForeignEntity> moreKeys = new ArrayList<ForeignEntity>();
			for (ForeignEntity key : keys) {
				Class<?> tableClass = key.referencedTable();
				if (hasForeignEntityAnnotation(tableClass)) {
					moreKeys.addAll(getForeignEntityAnnotations(tableClass));
				}
			}
			keys = moreKeys;
			res.addAll(keys);
		}
		return res;
	}

	static boolean hasForeignEntityAnnotation(final Class<?> c) {
		Field[] fields = c.getDeclaredFields();
		for (Field field : fields) {
			if (field.isAnnotationPresent(ForeignEntity.class)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * 
	 * @param c
	 * @return table alias if alias existed, otherwise will return table name
	 */
	static String getTableAliasOrName(final Class<?> c) {
		if (getTableAnnotation(c) == null) {
			logger.log(Level.WARNING, "cannot find any table");
			return null;
		}
		return getTableAnnotation(c).tableAlias().isEmpty() ? getTableAnnotation(
				c).name()
				: getTableAnnotation(c).tableAlias();
	}

	static boolean hasTableAlias(final Class<?> c) {
		if (getTableAnnotation(c) == null
				|| getTableAnnotation(c).tableAlias().isEmpty()) {
			return false;
		}
		return true;
	}

	static Table getTableAnnotation(final Class<?> c) {
		if (c.isAnnotationPresent(Table.class)) {
			return c.getAnnotation(Table.class);
		}
		return null;
	}

	static String toSqlString(final Class<?> c, final String key,
			final Object obj) {
		Class<?> type = getBasicColumnTypeByName(c, key);
		if (type == null) {
			logger.log(Level.SEVERE, key + " has no corresponding columns");
			return null;
		}
		if (type == Boolean.class) {
			return String.valueOf(((Boolean) obj).booleanValue());
		} else if (type == Long.class) {
			return String.valueOf(((Long) obj).longValue());
		} else if (type == Integer.class) {
			return String.valueOf(((Integer) obj).intValue());
		} else if (type == Float.class) {
			return String.valueOf(((Float) obj).floatValue());
		} else if (type == Timestamp.class) {
			return ((Timestamp) obj).getTimestamp().toString();
		} else {
			return "'" + obj.toString() + "'";
		}
	}

	private static Object runGetter(final Field field, final LogpieModel model) {
		for (Method method : model.getClass().getMethods()) {
			if (method.getName().startsWith("get")
					&& method.getName().length() == field.getName().length() + 3) {
				if (method.getName().toLowerCase()
						.endsWith(field.getName().toLowerCase())) {
					try {
						return method.invoke(model);
					} catch (IllegalAccessException e) {
						logger.log(Level.SEVERE,
								"cannot get access to this method");
						e.printStackTrace();
					} catch (IllegalArgumentException e) {
						logger.log(Level.SEVERE,
								"passed illegal argument to this method");
						e.printStackTrace();
					} catch (InvocationTargetException e) {
						logger.log(Level.SEVERE,
								"this method cannot be invoked");
						e.printStackTrace();
					}
				}
			}
		}
		logger.log(Level.WARNING, "cannot find getter method for this field");
		return null;
	}
}
